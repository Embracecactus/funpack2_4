
C:\Users\Administrator\AppData\Local\Temp\arduino-sketch-6EB819C3CF38B2FBD870D5D9B7AAE801/AVR64DD32.ino.elf:     file format elf32-avr


Disassembly of section .text:

00000000 <__vectors>:
__vectors():
../../../../crt1/gcrt1.S:61
   0:	47 c0       	rjmp	.+142    	; 0x90 <__ctors_end>
   2:	00 00       	nop
../../../../crt1/gcrt1.S:67
   4:	66 c0       	rjmp	.+204    	; 0xd2 <__bad_interrupt>
   6:	00 00       	nop
../../../../crt1/gcrt1.S:68
   8:	64 c0       	rjmp	.+200    	; 0xd2 <__bad_interrupt>
   a:	00 00       	nop
../../../../crt1/gcrt1.S:69
   c:	62 c0       	rjmp	.+196    	; 0xd2 <__bad_interrupt>
   e:	00 00       	nop
../../../../crt1/gcrt1.S:70
  10:	60 c0       	rjmp	.+192    	; 0xd2 <__bad_interrupt>
  12:	00 00       	nop
../../../../crt1/gcrt1.S:71
  14:	5e c0       	rjmp	.+188    	; 0xd2 <__bad_interrupt>
  16:	00 00       	nop
../../../../crt1/gcrt1.S:72
  18:	5c c0       	rjmp	.+184    	; 0xd2 <__bad_interrupt>
  1a:	00 00       	nop
../../../../crt1/gcrt1.S:73
  1c:	5a c0       	rjmp	.+180    	; 0xd2 <__bad_interrupt>
  1e:	00 00       	nop
../../../../crt1/gcrt1.S:74
  20:	58 c0       	rjmp	.+176    	; 0xd2 <__bad_interrupt>
  22:	00 00       	nop
../../../../crt1/gcrt1.S:75
  24:	56 c0       	rjmp	.+172    	; 0xd2 <__bad_interrupt>
  26:	00 00       	nop
../../../../crt1/gcrt1.S:76
  28:	54 c0       	rjmp	.+168    	; 0xd2 <__bad_interrupt>
  2a:	00 00       	nop
../../../../crt1/gcrt1.S:77
  2c:	52 c0       	rjmp	.+164    	; 0xd2 <__bad_interrupt>
  2e:	00 00       	nop
../../../../crt1/gcrt1.S:78
  30:	50 c0       	rjmp	.+160    	; 0xd2 <__bad_interrupt>
  32:	00 00       	nop
../../../../crt1/gcrt1.S:79
  34:	4e c0       	rjmp	.+156    	; 0xd2 <__bad_interrupt>
  36:	00 00       	nop
../../../../crt1/gcrt1.S:80
  38:	4c c0       	rjmp	.+152    	; 0xd2 <__bad_interrupt>
  3a:	00 00       	nop
../../../../crt1/gcrt1.S:81
  3c:	4a c0       	rjmp	.+148    	; 0xd2 <__bad_interrupt>
  3e:	00 00       	nop
../../../../crt1/gcrt1.S:82
  40:	48 c0       	rjmp	.+144    	; 0xd2 <__bad_interrupt>
  42:	00 00       	nop
../../../../crt1/gcrt1.S:83
  44:	46 c0       	rjmp	.+140    	; 0xd2 <__bad_interrupt>
  46:	00 00       	nop
../../../../crt1/gcrt1.S:84
  48:	44 c0       	rjmp	.+136    	; 0xd2 <__bad_interrupt>
  4a:	00 00       	nop
../../../../crt1/gcrt1.S:85
  4c:	42 c0       	rjmp	.+132    	; 0xd2 <__bad_interrupt>
  4e:	00 00       	nop
../../../../crt1/gcrt1.S:86
  50:	40 c0       	rjmp	.+128    	; 0xd2 <__bad_interrupt>
  52:	00 00       	nop
../../../../crt1/gcrt1.S:87
  54:	3e c0       	rjmp	.+124    	; 0xd2 <__bad_interrupt>
  56:	00 00       	nop
../../../../crt1/gcrt1.S:88
  58:	3c c0       	rjmp	.+120    	; 0xd2 <__bad_interrupt>
  5a:	00 00       	nop
../../../../crt1/gcrt1.S:89
  5c:	3a c0       	rjmp	.+116    	; 0xd2 <__bad_interrupt>
  5e:	00 00       	nop
../../../../crt1/gcrt1.S:90
  60:	38 c0       	rjmp	.+112    	; 0xd2 <__bad_interrupt>
  62:	00 00       	nop
../../../../crt1/gcrt1.S:91
  64:	36 c0       	rjmp	.+108    	; 0xd2 <__bad_interrupt>
  66:	00 00       	nop
../../../../crt1/gcrt1.S:92
  68:	34 c0       	rjmp	.+104    	; 0xd2 <__bad_interrupt>
  6a:	00 00       	nop
../../../../crt1/gcrt1.S:93
  6c:	32 c0       	rjmp	.+100    	; 0xd2 <__bad_interrupt>
  6e:	00 00       	nop
../../../../crt1/gcrt1.S:94
  70:	30 c0       	rjmp	.+96     	; 0xd2 <__bad_interrupt>
  72:	00 00       	nop
../../../../crt1/gcrt1.S:95
  74:	2e c0       	rjmp	.+92     	; 0xd2 <__bad_interrupt>
  76:	00 00       	nop
../../../../crt1/gcrt1.S:96
  78:	bd c0       	rjmp	.+378    	; 0x1f4 <__vector_30>
  7a:	00 00       	nop
../../../../crt1/gcrt1.S:97
  7c:	2a c0       	rjmp	.+84     	; 0xd2 <__bad_interrupt>
  7e:	00 00       	nop
../../../../crt1/gcrt1.S:98
  80:	28 c0       	rjmp	.+80     	; 0xd2 <__bad_interrupt>
  82:	00 00       	nop
../../../../crt1/gcrt1.S:99
  84:	26 c0       	rjmp	.+76     	; 0xd2 <__bad_interrupt>
  86:	00 00       	nop
../../../../crt1/gcrt1.S:100
  88:	24 c0       	rjmp	.+72     	; 0xd2 <__bad_interrupt>
  8a:	00 00       	nop
../../../../crt1/gcrt1.S:101
  8c:	22 c0       	rjmp	.+68     	; 0xd2 <__bad_interrupt>
	...

00000090 <__ctors_end>:
__trampolines_start():
../../../../crt1/gcrt1.S:230
  90:	11 24       	eor	r1, r1
../../../../crt1/gcrt1.S:231
  92:	1f be       	out	0x3f, r1	; 63
../../../../crt1/gcrt1.S:232
  94:	cf ef       	ldi	r28, 0xFF	; 255
../../../../crt1/gcrt1.S:234
  96:	cd bf       	out	0x3d, r28	; 61
../../../../crt1/gcrt1.S:236
  98:	df e7       	ldi	r29, 0x7F	; 127
../../../../crt1/gcrt1.S:237
  9a:	de bf       	out	0x3e, r29	; 62

0000009c <_initThreeStuff()>:
_Z15_initThreeStuffv():
C:\Users\Administrator\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/main.cpp:103

  /* Minimum: Reset if we wound up here through malfunction - this relies on user clearing the  *
   * register on startup, which is rarely done in Arduino land.                                 */
  void __attribute__((weak)) init_reset_flags() ;
  void __attribute__((weak)) init_reset_flags() {
    uint8_t flags = RSTCTRL.RSTFR;
  9c:	80 91 40 00 	lds	r24, 0x0040	; 0x800040 <__TEXT_REGION_LENGTH__+0x7f0040>
C:\Users\Administrator\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/main.cpp:104
    RSTCTRL.RSTFR = flags;
  a0:	80 93 40 00 	sts	0x0040, r24	; 0x800040 <__TEXT_REGION_LENGTH__+0x7f0040>
C:\Users\Administrator\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/main.cpp:105
    if (flags == 0) {
  a4:	81 11       	cpse	r24, r1
  a6:	05 c0       	rjmp	.+10     	; 0xb2 <_initThreeStuff()+0x16>
C:\Users\Administrator\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/main.cpp:106
      _PROTECTED_WRITE(RSTCTRL.SWRR, 1);
  a8:	98 ed       	ldi	r25, 0xD8	; 216
  aa:	21 e0       	ldi	r18, 0x01	; 1
  ac:	94 bf       	out	0x34, r25	; 52
  ae:	20 93 41 00 	sts	0x0041, r18	; 0x800041 <__TEXT_REGION_LENGTH__+0x7f0041>
C:\Users\Administrator\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/main.cpp:108
    }
    GPIOR0 = flags;
  b2:	8c bb       	out	0x1c, r24	; 28
C:\Users\Administrator\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/main.cpp:162
  * using optiboot if required               *
  *******************************************/
    // if we are, we also need to move the vectors. See longwinded deascription above.
    void _initThreeStuff() {
      init_reset_flags();
      _PROTECTED_WRITE(CPUINT_CTRLA,CPUINT_IVSEL_bm);
  b4:	88 ed       	ldi	r24, 0xD8	; 216
  b6:	90 e4       	ldi	r25, 0x40	; 64
  b8:	84 bf       	out	0x34, r24	; 52
  ba:	90 93 10 01 	sts	0x0110, r25	; 0x800110 <__TEXT_REGION_LENGTH__+0x7f0110>

000000be <__do_clear_bss>:
__do_clear_bss():
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2441
  be:	20 e6       	ldi	r18, 0x60	; 96
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2442
  c0:	a0 e0       	ldi	r26, 0x00	; 0
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2443
  c2:	b0 e6       	ldi	r27, 0x60	; 96
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2444
  c4:	01 c0       	rjmp	.+2      	; 0xc8 <.do_clear_bss_start>

000000c6 <.do_clear_bss_loop>:
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2446
  c6:	1d 92       	st	X+, r1

000000c8 <.do_clear_bss_start>:
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2448
  c8:	a4 30       	cpi	r26, 0x04	; 4
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2449
  ca:	b2 07       	cpc	r27, r18
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2450
  cc:	e1 f7       	brne	.-8      	; 0xc6 <.do_clear_bss_loop>
.do_clear_bss_start():
../../../../crt1/gcrt1.S:314
  ce:	ae d0       	rcall	.+348    	; 0x22c <main>
../../../../crt1/gcrt1.S:315
  d0:	30 c1       	rjmp	.+608    	; 0x332 <_exit>

000000d2 <__bad_interrupt>:
__vector_22():
  d2:	96 cf       	rjmp	.-212    	; 0x0 <__vectors>

000000d4 <micros>:
micros():
C:\Users\Administrator\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring.c:467
      #else /* TCA */
        uint8_t ticks;
      #endif
      uint8_t flags;
      /* Save current state and disable interrupts */
      uint8_t oldSREG = SREG;
  d4:	9f b7       	in	r25, 0x3f	; 63
C:\Users\Administrator\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring.c:468
      cli(); /* INTERRUPTS OFF */
  d6:	f8 94       	cli
C:\Users\Administrator\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring.c:484
        while (!(TCD0.STATUS & TCD_CMDRDY_bm)); // wait for sync - should be only one iteration of this loop
        flags = TCD0.INTFLAGS;
        ticks = TCD0.CAPTUREA;
        */
      #else /* = defined(MILLIS_USE_TCB) */
        ticks = _timer->CNT;
  d8:	e0 91 2a 0b 	lds	r30, 0x0B2A	; 0x800b2a <__TEXT_REGION_LENGTH__+0x7f0b2a>
  dc:	f0 91 2b 0b 	lds	r31, 0x0B2B	; 0x800b2b <__TEXT_REGION_LENGTH__+0x7f0b2b>
C:\Users\Administrator\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring.c:485
        flags = _timer->INTFLAGS;
  e0:	80 91 26 0b 	lds	r24, 0x0B26	; 0x800b26 <__TEXT_REGION_LENGTH__+0x7f0b26>
C:\Users\Administrator\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring.c:493
       * ISR has not fired. If we already read a high value of ticks, either we read it just before the overflow,
       * so we shouldn't increment overflows, or interrupts are disabled and micros isn't expected to work so it
       * doesn't matter.
       * Get current number of overflows and timer count */
      #if defined(MILLIS_USE_TCB)
        overflows = timingStruct.timer_millis;
  e4:	20 91 00 60 	lds	r18, 0x6000	; 0x806000 <__DATA_REGION_ORIGIN__>
  e8:	30 91 01 60 	lds	r19, 0x6001	; 0x806001 <__DATA_REGION_ORIGIN__+0x1>
  ec:	40 91 02 60 	lds	r20, 0x6002	; 0x806002 <__DATA_REGION_ORIGIN__+0x2>
  f0:	50 91 03 60 	lds	r21, 0x6003	; 0x806003 <__DATA_REGION_ORIGIN__+0x3>
C:\Users\Administrator\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring.c:498
      #else
        overflows = timingStruct.timer_overflow_count;
      #endif
      /* Turn interrupts back on, assuming they were on when micros was called. */
      SREG = oldSREG; /* INTERRUPTS ON */
  f4:	9f bf       	out	0x3f, r25	; 63
C:\Users\Administrator\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring.c:508
      */
      #if defined(MILLIS_USE_TCA)
        ticks = (TIME_TRACKING_TIMER_PERIOD) - ticks;
        if ((flags & TCA_SPLIT_HUNF_bm) && (ticks < 0x03)) {
      #else /* = defined(MILLIS_USE_TCB) */
        if ((flags & TCB_CAPT_bm) && !(ticks & 0xFF00)) {
  f6:	80 ff       	sbrs	r24, 0
  f8:	08 c0       	rjmp	.+16     	; 0x10a <__EEPROM_REGION_LENGTH__+0xa>
  fa:	cf 01       	movw	r24, r30
  fc:	88 27       	eor	r24, r24
  fe:	89 2b       	or	r24, r25
 100:	21 f4       	brne	.+8      	; 0x10a <__EEPROM_REGION_LENGTH__+0xa>
C:\Users\Administrator\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring.c:513
      #endif
      #if (defined(MILLIS_USE_TCB) && (F_CPU <= 2000000UL))
        overflows += 2;
      #else
        overflows++;
 102:	2f 5f       	subi	r18, 0xFF	; 255
 104:	3f 4f       	sbci	r19, 0xFF	; 255
 106:	4f 4f       	sbci	r20, 0xFF	; 255
 108:	5f 4f       	sbci	r21, 0xFF	; 255
C:\Users\Administrator\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring.c:662
         * 57 replaced with 30 save 27 clocks @ 12 = 2 us saved
         * 67 replaced with 32 save 35 clocks @ 24 = 1.5us saved
         * 77 replaced with 34 save 43 clocks @ 48 = 1 us saved
         */
        #elif (F_CPU == 48000000UL || F_CPU == 24000000UL || F_CPU == 12000000UL || F_CPU == 6000000UL || F_CPU == 3000000UL)
          __asm__ __volatile__(
 10a:	0f 01       	movw	r0, r30
 10c:	16 94       	lsr	r1
 10e:	07 94       	ror	r0
 110:	16 94       	lsr	r1
 112:	07 94       	ror	r0
 114:	16 94       	lsr	r1
 116:	07 94       	ror	r0
 118:	16 94       	lsr	r1
 11a:	07 94       	ror	r0
 11c:	f0 01       	movw	r30, r0
 11e:	16 94       	lsr	r1
 120:	07 94       	ror	r0
 122:	e0 0d       	add	r30, r0
 124:	f1 1d       	adc	r31, r1
 126:	16 94       	lsr	r1
 128:	07 94       	ror	r0
 12a:	10 2c       	mov	r1, r0
 12c:	16 94       	lsr	r1
 12e:	01 18       	sub	r0, r1
 130:	16 94       	lsr	r1
 132:	01 0c       	add	r0, r1
 134:	16 94       	lsr	r1
 136:	01 18       	sub	r0, r1
 138:	16 94       	lsr	r1
 13a:	01 0c       	add	r0, r1
 13c:	16 94       	lsr	r1
 13e:	01 18       	sub	r0, r1
 140:	16 94       	lsr	r1
 142:	16 94       	lsr	r1
 144:	01 0c       	add	r0, r1
 146:	11 24       	eor	r1, r1
 148:	e0 19       	sub	r30, r0
 14a:	f1 09       	sbc	r31, r1
C:\Users\Administrator\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring.c:707
            "add r0,r1"     "\n\t"  // + ticks >> 9
            "eor r1,r1"     "\n\t"  // clear out r1
            "sub %A0,r0"    "\n\t"  // Add the sum of terms that fit in a byte to what was ticks in old code.
            "sbc %B0,r1"    "\n"    // carry - see,this is why AVR needs a known zero.
            : "+r" (ticks));        // Do the rest in C. ticks is a read/write operand.
          microseconds = overflows * 1000 + ticks; // nice and clean.
 14c:	a8 ee       	ldi	r26, 0xE8	; 232
 14e:	b3 e0       	ldi	r27, 0x03	; 3
 150:	d7 d0       	rcall	.+430    	; 0x300 <__muluhisi3>
 152:	6e 0f       	add	r22, r30
 154:	7f 1f       	adc	r23, r31
 156:	81 1d       	adc	r24, r1
 158:	91 1d       	adc	r25, r1
C:\Users\Administrator\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring.c:877
          microseconds = ((overflows * millisClockCyclesToMicroseconds(TIME_TRACKING_CYCLES_PER_OVF))
                        + (ticks * (millisClockCyclesToMicroseconds(TIME_TRACKING_CYCLES_PER_OVF) / TIME_TRACKING_TIMER_PERIOD)));
        #endif
      #endif // end of timer-specific part of micros calculations
      return microseconds;
    }
 15a:	08 95       	ret

0000015c <delay.constprop.8>:
delay.constprop.8():
C:\Users\Administrator\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring.c:938


#if (!(defined(MILLIS_USE_TIMERNONE) || defined(MILLIS_USE_TIMERRTC) || (F_CPU == 7000000L || F_CPU == 14000000)))
  // delay implementation when we do have micros() - we know it won't work at 7 or 14, and those can be generated
  // from internal, and switch logic is in even though micros isn't.
  void delay(unsigned long ms)
 15c:	cf 92       	push	r12
 15e:	df 92       	push	r13
 160:	ef 92       	push	r14
 162:	ff 92       	push	r15
 164:	cf 93       	push	r28
C:\Users\Administrator\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring.c:940
  {
    uint16_t start = (uint16_t)micros();
 166:	df 93       	push	r29
 168:	b5 df       	rcall	.-150    	; 0xd4 <micros>
 16a:	eb 01       	movw	r28, r22
 16c:	88 ee       	ldi	r24, 0xE8	; 232
 16e:	c8 2e       	mov	r12, r24
 170:	83 e0       	ldi	r24, 0x03	; 3
 172:	d8 2e       	mov	r13, r24
 174:	e1 2c       	mov	r14, r1
C:\Users\Administrator\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring.c:944
    while (true) {
      if (ms == 0) break;
      yield();
      uint16_t us_passed = (uint16_t)micros() - start;
 176:	f1 2c       	mov	r15, r1
 178:	ad df       	rcall	.-166    	; 0xd4 <micros>
 17a:	6c 1b       	sub	r22, r28
 17c:	7d 0b       	sbc	r23, r29
C:\Users\Administrator\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring.c:945
      if (us_passed >= 1000) {
 17e:	68 3e       	cpi	r22, 0xE8	; 232
 180:	73 40       	sbci	r23, 0x03	; 3
 182:	d0 f3       	brcs	.-12     	; 0x178 <delay.constprop.8+0x1c>
C:\Users\Administrator\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring.c:946
        ms--;
 184:	81 e0       	ldi	r24, 0x01	; 1
 186:	c8 1a       	sub	r12, r24
 188:	d1 08       	sbc	r13, r1
 18a:	e1 08       	sbc	r14, r1
 18c:	f1 08       	sbc	r15, r1
C:\Users\Administrator\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring.c:947
        start += 1000;
 18e:	c8 51       	subi	r28, 0x18	; 24
 190:	dc 4f       	sbci	r29, 0xFC	; 252
C:\Users\Administrator\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring.c:942
  // from internal, and switch logic is in even though micros isn't.
  void delay(unsigned long ms)
  {
    uint16_t start = (uint16_t)micros();
    while (true) {
      if (ms == 0) break;
 192:	c1 14       	cp	r12, r1
 194:	d1 04       	cpc	r13, r1
 196:	e1 04       	cpc	r14, r1
 198:	f1 04       	cpc	r15, r1
 19a:	71 f7       	brne	.-36     	; 0x178 <delay.constprop.8+0x1c>
C:\Users\Administrator\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring.c:950
      if (us_passed >= 1000) {
        ms--;
        start += 1000;
      }
    }
  }
 19c:	df 91       	pop	r29
 19e:	cf 91       	pop	r28
 1a0:	ff 90       	pop	r15
 1a2:	ef 90       	pop	r14
 1a4:	df 90       	pop	r13
 1a6:	cf 90       	pop	r12
 1a8:	08 95       	ret

000001aa <digitalWrite.constprop.4>:
digitalWrite.constprop.4():
C:\Users\Administrator\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring_digital.c:227
  you could digitalWrite() a pin while it's an input, to ensure
  that the value of the port was set correctly when it was
  changed to an output. Code in the wild relies on this behavior. */

  if (val == LOW) { /* If LOW */
    port->OUTCLR = bit_mask;
 1aa:	90 e2       	ldi	r25, 0x20	; 32
C:\Users\Administrator\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring_digital.c:226
  the behavior of digitalWrite() on classic AVR devices, where
  you could digitalWrite() a pin while it's an input, to ensure
  that the value of the port was set correctly when it was
  changed to an output. Code in the wild relies on this behavior. */

  if (val == LOW) { /* If LOW */
 1ac:	81 11       	cpse	r24, r1
 1ae:	1b c0       	rjmp	.+54     	; 0x1e6 <digitalWrite.constprop.4+0x3c>
C:\Users\Administrator\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring_digital.c:227
    port->OUTCLR = bit_mask;
 1b0:	90 93 a6 04 	sts	0x04A6, r25	; 0x8004a6 <__TEXT_REGION_LENGTH__+0x7f04a6>
C:\Users\Administrator\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring_digital.c:251
  } else {
    port->OUTSET = bit_mask;
  }

  /* Input direction */
  if (!(port->DIR & bit_mask)) {
 1b4:	90 91 a0 04 	lds	r25, 0x04A0	; 0x8004a0 <__TEXT_REGION_LENGTH__+0x7f04a0>
 1b8:	95 fd       	sbrc	r25, 5
 1ba:	0a c0       	rjmp	.+20     	; 0x1d0 <digitalWrite.constprop.4+0x26>
C:\Users\Administrator\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring_digital.c:264

    /* Calculate where pin control register is */
    volatile uint8_t *pin_ctrl_reg = getPINnCTRLregister(port, bit_pos);

    /* Save system status and disable interrupts */
    uint8_t status = SREG;
 1bc:	9f b7       	in	r25, 0x3f	; 63
C:\Users\Administrator\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring_digital.c:265
    cli();
 1be:	f8 94       	cli
C:\Users\Administrator\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring_digital.c:267

    if (val == LOW) {
 1c0:	81 11       	cpse	r24, r1
 1c2:	14 c0       	rjmp	.+40     	; 0x1ec <digitalWrite.constprop.4+0x42>
C:\Users\Administrator\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring_digital.c:269
      /* Disable pullup */
      *pin_ctrl_reg &= ~PORT_PULLUPEN_bm;
 1c4:	80 91 b5 04 	lds	r24, 0x04B5	; 0x8004b5 <__TEXT_REGION_LENGTH__+0x7f04b5>
 1c8:	87 7f       	andi	r24, 0xF7	; 247
C:\Users\Administrator\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring_digital.c:272
    } else {
      /* Enable pull-up */
      *pin_ctrl_reg |= PORT_PULLUPEN_bm;
 1ca:	80 93 b5 04 	sts	0x04B5, r24	; 0x8004b5 <__TEXT_REGION_LENGTH__+0x7f04b5>
C:\Users\Administrator\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring_digital.c:276
    }

    /* Restore system status */
    SREG = status;
 1ce:	9f bf       	out	0x3f, r25	; 63
digitalPinToTimerNow():
C:\Users\Administrator\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring_analog.c:790
        return TIMERA1;                              /* mux options, not 3-channel ones on bit 4:6 */
      }
    }
  #else
    if (__PeripheralControl & TIMERA0) {               /* here we don't need to store tcamux */
      if ((PORTMUX.TCAROUTEA & PORTMUX_TCA0_gm) == port) { /* because it is only used once */
 1d0:	80 91 e7 05 	lds	r24, 0x05E7	; 0x8005e7 <__TEXT_REGION_LENGTH__+0x7f05e7>
 1d4:	87 70       	andi	r24, 0x07	; 7
 1d6:	85 30       	cpi	r24, 0x05	; 5
 1d8:	29 f4       	brne	.+10     	; 0x1e4 <digitalWrite.constprop.4+0x3a>
turnOffPWM():
C:\Users\Administrator\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring_digital.c:130
  /* TCA0 */
  case TIMERA0:
    /* Bit position will give output channel */
    if (bit_mask > 0x04)  bit_mask <<= 1; // there's a blank bit in the middle
    /* Disable corresponding channel */
    TCA0.SPLIT.CTRLB &= ~bit_mask;
 1da:	80 91 01 0a 	lds	r24, 0x0A01	; 0x800a01 <__TEXT_REGION_LENGTH__+0x7f0a01>
 1de:	8f 7b       	andi	r24, 0xBF	; 191
 1e0:	80 93 01 0a 	sts	0x0A01, r24	; 0x800a01 <__TEXT_REGION_LENGTH__+0x7f0a01>
digitalWrite.constprop.4():
C:\Users\Administrator\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring_digital.c:289
   * analogWritten() 255, then digitallyWritten() to HIGH, which
   * would turn it off for the time between turnOffPWM() and
   * PORT->OUTCLR)
   * Since there's no penalty, why make a glitch we don't have to? */
  turnOffPWM(pin);
}
 1e4:	08 95       	ret
C:\Users\Administrator\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring_digital.c:247
    // val will now be 0 (LOW) if the toggling made it LOW
    // or bit_mask if not. And further down, we only need to
    // know if it's
  /* If HIGH OR  > TOGGLE  */
  } else {
    port->OUTSET = bit_mask;
 1e6:	90 93 a5 04 	sts	0x04A5, r25	; 0x8004a5 <__TEXT_REGION_LENGTH__+0x7f04a5>
 1ea:	e4 cf       	rjmp	.-56     	; 0x1b4 <digitalWrite.constprop.4+0xa>
C:\Users\Administrator\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring_digital.c:272
    if (val == LOW) {
      /* Disable pullup */
      *pin_ctrl_reg &= ~PORT_PULLUPEN_bm;
    } else {
      /* Enable pull-up */
      *pin_ctrl_reg |= PORT_PULLUPEN_bm;
 1ec:	80 91 b5 04 	lds	r24, 0x04B5	; 0x8004b5 <__TEXT_REGION_LENGTH__+0x7f04b5>
 1f0:	88 60       	ori	r24, 0x08	; 8
 1f2:	eb cf       	rjmp	.-42     	; 0x1ca <digitalWrite.constprop.4+0x20>

000001f4 <__vector_30>:
__vector_30():
C:\Users\Administrator\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring.c:194
      }
      RTC.INTFLAGS = RTC_OVF_bm | RTC_CMP_bm; // clear flag
    }
  #else
    ISR(MILLIS_VECTOR, ISR_NAKED) {
      __asm__ __volatile__(
 1f4:	ef 93       	push	r30
 1f6:	ff 93       	push	r31
C:\Users\Administrator\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring.c:199
      "push       r30"          "\n\t" // First we make room for the pointer to timingStruct by pushing the Z registers
      "push       r31"          "\n\t" //
      ::);
    #if defined(MILLIS_USE_TCB)
      __asm__ __volatile__(
 1f8:	e0 e0       	ldi	r30, 0x00	; 0
 1fa:	f0 e6       	ldi	r31, 0x60	; 96
 1fc:	8f 93       	push	r24
 1fe:	8f b7       	in	r24, 0x3f	; 63
 200:	8f 93       	push	r24
 202:	80 81       	ld	r24, Z
 204:	8f 5f       	subi	r24, 0xFF	; 255
 206:	80 83       	st	Z, r24
 208:	81 81       	ldd	r24, Z+1	; 0x01
 20a:	8f 4f       	sbci	r24, 0xFF	; 255
 20c:	81 83       	std	Z+1, r24	; 0x01
 20e:	82 81       	ldd	r24, Z+2	; 0x02
 210:	8f 4f       	sbci	r24, 0xFF	; 255
 212:	82 83       	std	Z+2, r24	; 0x02
 214:	83 81       	ldd	r24, Z+3	; 0x03
 216:	8f 4f       	sbci	r24, 0xFF	; 255
 218:	83 83       	std	Z+3, r24	; 0x03
 21a:	81 e0       	ldi	r24, 0x01	; 1
 21c:	80 93 26 0b 	sts	0x0B26, r24	; 0x800b26 <__TEXT_REGION_LENGTH__+0x7f0b26>
 220:	8f 91       	pop	r24
 222:	8f bf       	out	0x3f, r24	; 63
 224:	8f 91       	pop	r24
 226:	ff 91       	pop	r31
 228:	ef 91       	pop	r30
 22a:	18 95       	reti

0000022c <main>:
main():
C:\Users\Administrator\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring.c:1642
      _PROTECTED_WRITE(CLKCTRL_OSCHFCTRLA, (0x0B << 2));
    #elif (F_CPU == 28000000)
      /* Overclocked - generally quite reliable at room temperature, but a dumb frequency (see PWM section) */
      _PROTECTED_WRITE(CLKCTRL_OSCHFCTRLA, (0x0A << 2));
    #elif (F_CPU == 24000000)
      _PROTECTED_WRITE(CLKCTRL_OSCHFCTRLA, (0x09 << 2));
 22c:	88 ed       	ldi	r24, 0xD8	; 216
 22e:	94 e2       	ldi	r25, 0x24	; 36
 230:	84 bf       	out	0x34, r24	; 52
 232:	90 93 68 00 	sts	0x0068, r25	; 0x800068 <__TEXT_REGION_LENGTH__+0x7f0068>
init_TCA0():
C:\Users\Administrator\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring.c:1912
}

void __attribute__((weak)) init_TCA0() {
  /* TCA0_PINS from pins_arduino.h */
  /* Enable Split Mode to get more PWM pins, since analogWrite() only provides 8-bit PWM anyway*/
  TCA0.SPLIT.CTRLD = TCA_SPLIT_SPLITM_bm;
 236:	21 e0       	ldi	r18, 0x01	; 1
 238:	20 93 03 0a 	sts	0x0A03, r18	; 0x800a03 <__TEXT_REGION_LENGTH__+0x7f0a03>
C:\Users\Administrator\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring.c:1917

  // Only 1 WGM so no need to specifically set up.

  /* Period setting, 8-bit register in SPLIT mode */
  TCA0.SPLIT.LPER    = PWM_TIMER_PERIOD;
 23c:	9e ef       	ldi	r25, 0xFE	; 254
 23e:	90 93 26 0a 	sts	0x0A26, r25	; 0x800a26 <__TEXT_REGION_LENGTH__+0x7f0a26>
C:\Users\Administrator\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring.c:1918
  TCA0.SPLIT.HPER    = PWM_TIMER_PERIOD;
 242:	90 93 27 0a 	sts	0x0A27, r25	; 0x800a27 <__TEXT_REGION_LENGTH__+0x7f0a27>
C:\Users\Administrator\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring.c:1945
    TCA0.SPLIT.CTRLA   = (TCA_SPLIT_CLKSEL_DIV256_gc) | (TCA_SPLIT_ENABLE_bm);
  #elif (F_CPU > 5000000) // use 64 divider unless it's 5 MHz or under
    #if defined(MILLIS_USE_TIMERA0) && (TIME_TRACKING_TIMER_DIVIDER != 64)
      #error "wiring.c and timers.h want to set millis timer TCA0 to different divider"
    #endif
    TCA0.SPLIT.CTRLA   =  (TCA_SPLIT_CLKSEL_DIV64_gc) | (TCA_SPLIT_ENABLE_bm);
 246:	8b e0       	ldi	r24, 0x0B	; 11
 248:	80 93 00 0a 	sts	0x0A00, r24	; 0x800a00 <__TEXT_REGION_LENGTH__+0x7f0a00>
init_timers():
C:\Users\Administrator\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring.c:1893
  init_TCA0();
  #if (defined(TCA1))
    PORTMUX.TCAROUTEA = TCA0_PINS | TCA1_PINS;
    init_TCA1();
  #else
    PORTMUX.TCAROUTEA = TCA0_PINS;
 24c:	85 e0       	ldi	r24, 0x05	; 5
 24e:	80 93 e7 05 	sts	0x05E7, r24	; 0x8005e7 <__TEXT_REGION_LENGTH__+0x7f05e7>
init_TCBs():
C:\Users\Administrator\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring.c:2000
 * Set up routing (defined in pins_arduino.h)
 * Notice how there's no semicolon until after the preprocessor conditionals.
 * In other words, that's all one line.
 */

  PORTMUX.TCBROUTEA = 0
 252:	10 92 e8 05 	sts	0x05E8, r1	; 0x8005e8 <__TEXT_REGION_LENGTH__+0x7f05e8>
C:\Users\Administrator\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring.c:2051
    #elif defined(MILLIS_USE_TIMERB4)
      if(timer_B != (TCB_t *)&TCB4)
    #endif
    {
      // 8 bit PWM mode, but do not enable output yet, will do in analogWrite()
      timer_B->CTRLB = (TCB_CNTMODE_PWM8_gc);
 256:	37 e0       	ldi	r19, 0x07	; 7
 258:	30 93 01 0b 	sts	0x0B01, r19	; 0x800b01 <__TEXT_REGION_LENGTH__+0x7f0b01>
C:\Users\Administrator\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring.c:2054

      // Assign 8-bit period
      timer_B->CCMPL = PWM_TIMER_PERIOD; // TOP = 254 see section at start
 25c:	90 93 0c 0b 	sts	0x0B0C, r25	; 0x800b0c <__TEXT_REGION_LENGTH__+0x7f0b0c>
C:\Users\Administrator\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring.c:2057
      // default duty 50% - we have to set something here because of the
      // errata, otherwise CCMP will not get the CCMPL either.
      timer_B->CCMPH = PWM_TIMER_COMPARE;
 260:	10 92 0d 0b 	sts	0x0B0D, r1	; 0x800b0d <__TEXT_REGION_LENGTH__+0x7f0b0d>
C:\Users\Administrator\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring.c:2060

      // Use TCA clock (250kHz, +/- 50%) and enable
      timer_B->CTRLA = (TCB_CLKSEL_TCA0_gc) | (TCB_ENABLE_bm);
 264:	80 93 00 0b 	sts	0x0B00, r24	; 0x800b00 <__TEXT_REGION_LENGTH__+0x7f0b00>
C:\Users\Administrator\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring.c:2051
    #elif defined(MILLIS_USE_TIMERB4)
      if(timer_B != (TCB_t *)&TCB4)
    #endif
    {
      // 8 bit PWM mode, but do not enable output yet, will do in analogWrite()
      timer_B->CTRLB = (TCB_CNTMODE_PWM8_gc);
 268:	30 93 11 0b 	sts	0x0B11, r19	; 0x800b11 <__TEXT_REGION_LENGTH__+0x7f0b11>
C:\Users\Administrator\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring.c:2054

      // Assign 8-bit period
      timer_B->CCMPL = PWM_TIMER_PERIOD; // TOP = 254 see section at start
 26c:	90 93 1c 0b 	sts	0x0B1C, r25	; 0x800b1c <__TEXT_REGION_LENGTH__+0x7f0b1c>
C:\Users\Administrator\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring.c:2057
      // default duty 50% - we have to set something here because of the
      // errata, otherwise CCMP will not get the CCMPL either.
      timer_B->CCMPH = PWM_TIMER_COMPARE;
 270:	10 92 1d 0b 	sts	0x0B1D, r1	; 0x800b1d <__TEXT_REGION_LENGTH__+0x7f0b1d>
C:\Users\Administrator\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring.c:2060

      // Use TCA clock (250kHz, +/- 50%) and enable
      timer_B->CTRLA = (TCB_CLKSEL_TCA0_gc) | (TCB_ENABLE_bm);
 274:	80 93 10 0b 	sts	0x0B10, r24	; 0x800b10 <__TEXT_REGION_LENGTH__+0x7f0b10>
init_TCD0():
C:\Users\Administrator\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring.c:2104
 * be set in the status register. We skip checking this here because, as we do many places the  *
 * initiialization functions assume that the chip starts from a reset condition.                */

void __attribute__((weak)) init_TCD0() {
  #if defined(USE_TIMERD0_PWM) || defined (MILLIS_USE_TIMERD0)
    TCD0.CMPACLR  = 0x0FFF;
 278:	4f ef       	ldi	r20, 0xFF	; 255
 27a:	5f e0       	ldi	r21, 0x0F	; 15
 27c:	40 93 aa 0b 	sts	0x0BAA, r20	; 0x800baa <__TEXT_REGION_LENGTH__+0x7f0baa>
 280:	50 93 ab 0b 	sts	0x0BAB, r21	; 0x800bab <__TEXT_REGION_LENGTH__+0x7f0bab>
C:\Users\Administrator\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring.c:2108
    // Match with CMPBCLR clears all outputs. For normal PWM this just needs to be higher than
    // it will count to - so set to maximum (other settings used for non-overlapping PWM and
    // other advanced functionality)
    TCD0.CTRLC    = 0x80;                   // WOD outputs PWM B, WOC outputs PWM A
 284:	90 e8       	ldi	r25, 0x80	; 128
 286:	90 93 82 0b 	sts	0x0B82, r25	; 0x800b82 <__TEXT_REGION_LENGTH__+0x7f0b82>
C:\Users\Administrator\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring.c:2110
    // That doesn't need to be that way, but I declare that that's all we support through analogWrite()
    TCD0.CTRLB    = TIMERD0_WGMODE_SETTING;
 28a:	10 92 81 0b 	sts	0x0B81, r1	; 0x800b81 <__TEXT_REGION_LENGTH__+0x7f0b81>
C:\Users\Administrator\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring.c:2113
    // One ramp or dual slope are the only options that are viable to reproduce classic behavior without
    // considerable calculation overhead. We use one-ramp mode
    TCD0.CMPBCLR  = TIMERD0_TOP_SETTING;
 28e:	4b ef       	ldi	r20, 0xFB	; 251
 290:	53 e0       	ldi	r21, 0x03	; 3
 292:	40 93 ae 0b 	sts	0x0BAE, r20	; 0x800bae <__TEXT_REGION_LENGTH__+0x7f0bae>
 296:	50 93 af 0b 	sts	0x0BAF, r21	; 0x800baf <__TEXT_REGION_LENGTH__+0x7f0baf>
C:\Users\Administrator\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring.c:2122
    #if defined(TIMERD0_SET_CLOCK)
      _PROTECTED_WRITE(CLKCTRL_OSCHFCTRLA, (TIMERD0_SET_CLOCK));
    #endif


    TCD0.CTRLA    = TIMERD0_CLOCK_SETTING | TCD_ENABLE_bm;
 29a:	91 e7       	ldi	r25, 0x71	; 113
 29c:	90 93 80 0b 	sts	0x0B80, r25	; 0x800b80 <__TEXT_REGION_LENGTH__+0x7f0b80>
init_timers():
C:\Users\Administrator\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring.c:1899
  #endif
  init_TCBs();
  #if (defined(TCD0) && defined(USE_TIMERD0_PWM) && !defined(MILLIS_USE_TIMERD0))
    init_TCD0();
    #if defined(ERRATA_TCD_PORTMUX) && ERRATA_TCD_PORTMUX == 0 && defined(TCD0_PINS)
      PORTMUX.TCDROUTEA = TCD0_PINS;
 2a0:	10 92 e9 05 	sts	0x05E9, r1	; 0x8005e9 <__TEXT_REGION_LENGTH__+0x7f05e9>
init_ADC0():
C:\Users\Administrator\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring.c:1536
    #elif F_CPU >= 36000000
      ADC0.CTRLC = ADC_PRESC_DIV28_gc; // 1.286 @ 36 MHz
    #elif F_CPU >  28000000
      ADC0.CTRLC = ADC_PRESC_DIV24_gc; // 1.33 @ 32 MHz, 1.
    #elif F_CPU >= 24000000
      ADC0.CTRLC = ADC_PRESC_DIV20_gc; // 1.2 @ 24, 1.25 @ 25, 1.4 @ 28  MHz
 2a4:	80 93 02 06 	sts	0x0602, r24	; 0x800602 <__TEXT_REGION_LENGTH__+0x7f0602>
C:\Users\Administrator\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring.c:1548
    #elif F_CPU >= 4000000
      ADC0.CTRLC = ADC_PRESC_DIV4_gc;  // 1 MHz
    #else  // 1 MHz / 2 = 500 kHz - the lowest setting
      ADC0.CTRLC = ADC_PRESC_DIV2_gc;
    #endif
    ADC0.SAMPCTRL = 14; // 16 ADC clock sampling time - should be about the same amount of *time* as originally?
 2a8:	9e e0       	ldi	r25, 0x0E	; 14
 2aa:	90 93 05 06 	sts	0x0605, r25	; 0x800605 <__TEXT_REGION_LENGTH__+0x7f0605>
C:\Users\Administrator\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring.c:1550
    // This is WAY conservative! We could drop it down...
    ADC0.CTRLD = ADC_INITDLY_DLY64_gc; // VREF can take 50uS to become ready, and we're running the ADC clock
 2ae:	90 e6       	ldi	r25, 0x60	; 96
 2b0:	90 93 03 06 	sts	0x0603, r25	; 0x800603 <__TEXT_REGION_LENGTH__+0x7f0603>
C:\Users\Administrator\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring.c:1553
    // at around 1 MHz, so we want 64 ADC clocks when we start up a new reference so we don't get bad readings at first
    /* Enable ADC */
    ADC0.CTRLA = ADC_ENABLE_bm | ADC_RESSEL_10BIT_gc;
 2b4:	80 93 00 06 	sts	0x0600, r24	; 0x800600 <__TEXT_REGION_LENGTH__+0x7f0600>
analogReference():
C:\Users\Administrator\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring_analog.c:117


void analogReference(uint8_t mode) {
  check_valid_analog_ref(mode);
  if (mode < 7 && mode !=4) {
    VREF.ADC0REF = (VREF.ADC0REF & ~(VREF_REFSEL_gm))|(mode);
 2b8:	80 91 b0 00 	lds	r24, 0x00B0	; 0x8000b0 <__TEXT_REGION_LENGTH__+0x7f00b0>
 2bc:	88 7f       	andi	r24, 0xF8	; 248
 2be:	85 60       	ori	r24, 0x05	; 5
 2c0:	80 93 b0 00 	sts	0x00B0, r24	; 0x8000b0 <__TEXT_REGION_LENGTH__+0x7f00b0>
DACReference():
C:\Users\Administrator\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring_analog.c:124
}

void DACReference(uint8_t mode) {
  check_valid_analog_ref(mode);
  if (mode < 7 && mode !=4) {
    VREF.DAC0REF = (VREF.DAC0REF & ~(VREF_REFSEL_gm))|(mode);
 2c4:	80 91 b2 00 	lds	r24, 0x00B2	; 0x8000b2 <__TEXT_REGION_LENGTH__+0x7f00b2>
 2c8:	88 7f       	andi	r24, 0xF8	; 248
 2ca:	85 60       	ori	r24, 0x05	; 5
 2cc:	80 93 b2 00 	sts	0x00B2, r24	; 0x8000b2 <__TEXT_REGION_LENGTH__+0x7f00b2>
init_millis():
C:\Users\Administrator\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring.c:1448
      #endif
      RTC.INTCTRL         = 0x01; // enable overflow interrupt
      RTC.CTRLA           = (RTC_RUNSTDBY_bm|RTC_RTCEN_bm|RTC_PRESCALER_DIV32_gc);//fire it up, prescale by 32.
    */
    #else // It's a type b timer - we have already errored out if that wasn't defined
      _timer->CCMP = TIME_TRACKING_TIMER_PERIOD;
 2d0:	8f ed       	ldi	r24, 0xDF	; 223
 2d2:	9e e2       	ldi	r25, 0x2E	; 46
 2d4:	80 93 2c 0b 	sts	0x0B2C, r24	; 0x800b2c <__TEXT_REGION_LENGTH__+0x7f0b2c>
 2d8:	90 93 2d 0b 	sts	0x0B2D, r25	; 0x800b2d <__TEXT_REGION_LENGTH__+0x7f0b2d>
C:\Users\Administrator\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring.c:1450
      // Enable timer interrupt, but clear the rest of register
      _timer->INTCTRL = TCB_CAPT_bm;
 2dc:	20 93 25 0b 	sts	0x0B25, r18	; 0x800b25 <__TEXT_REGION_LENGTH__+0x7f0b25>
C:\Users\Administrator\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring.c:1452
      // Clear timer mode (since it will have been set as PWM by init())
      _timer->CTRLB = 0;
 2e0:	10 92 21 0b 	sts	0x0B21, r1	; 0x800b21 <__TEXT_REGION_LENGTH__+0x7f0b21>
C:\Users\Administrator\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring.c:1454
      // CLK_PER/1 is 0b00, . CLK_PER/2 is 0b01, so bitwise OR of valid divider with enable works
      _timer->CTRLA = TIME_TRACKING_TIMER_DIVIDER|TCB_ENABLE_bm;  // Keep this last before enabling interrupts to ensure tracking as accurate as possible
 2e4:	83 e0       	ldi	r24, 0x03	; 3
 2e6:	80 93 20 0b 	sts	0x0B20, r24	; 0x800b20 <__TEXT_REGION_LENGTH__+0x7f0b20>
main():
C:\Users\Administrator\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/main.cpp:52
 * just waiting for the DU-series now                                                           */
int main() {
  onBeforeInit(); // Emnpty callback called before init but after the .init stuff. First normal code executed
  init(); // Interrupts are turned on just prior to init() returning.
  initVariant();
  if (!onAfterInit()) sei();  // enable interrupts.
 2ea:	78 94       	sei
_pinMode():
C:\Users\Administrator\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring_digital.c:86
    return;                             /* ignore invalid pins passed at runtime */
  }
  PORT_t *port = digitalPinToPortStruct(pin);
  // if (port == NULL) return;           /* skip this test; if bit_mask isn't NOT_A_PIN, port won't be null - if it is, pins_arduino.h contains errors and we can't expect any digital I/O to work correctly.
  if (mode == OUTPUT) {
    port->DIRSET = bit_mask;            /* Configure direction as output and done*/
 2ec:	80 e2       	ldi	r24, 0x20	; 32
 2ee:	80 93 a1 04 	sts	0x04A1, r24	; 0x8004a1 <__TEXT_REGION_LENGTH__+0x7f04a1>
loop():
E:\lijian\FUNPACK\funpack2_4\程序\AVR64DD32/AVR64DD32.ino:12
 2f2:	81 e0       	ldi	r24, 0x01	; 1
 2f4:	5a df       	rcall	.-332    	; 0x1aa <digitalWrite.constprop.4>
E:\lijian\FUNPACK\funpack2_4\程序\AVR64DD32/AVR64DD32.ino:13
 2f6:	32 df       	rcall	.-412    	; 0x15c <delay.constprop.8>
E:\lijian\FUNPACK\funpack2_4\程序\AVR64DD32/AVR64DD32.ino:14
 2f8:	80 e0       	ldi	r24, 0x00	; 0
 2fa:	57 df       	rcall	.-338    	; 0x1aa <digitalWrite.constprop.4>
E:\lijian\FUNPACK\funpack2_4\程序\AVR64DD32/AVR64DD32.ino:15
 2fc:	2f df       	rcall	.-418    	; 0x15c <delay.constprop.8>
 2fe:	f9 cf       	rjmp	.-14     	; 0x2f2 <main+0xc6>

00000300 <__muluhisi3>:
__muluhisi3():
 300:	09 d0       	rcall	.+18     	; 0x314 <__umulhisi3>
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:627
 302:	a5 9f       	mul	r26, r21
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:628
 304:	90 0d       	add	r25, r0
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:629
 306:	b4 9f       	mul	r27, r20
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:630
 308:	90 0d       	add	r25, r0
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:631
 30a:	a4 9f       	mul	r26, r20
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:632
 30c:	80 0d       	add	r24, r0
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:633
 30e:	91 1d       	adc	r25, r1
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:634
 310:	11 24       	eor	r1, r1
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:635
 312:	08 95       	ret

00000314 <__umulhisi3>:
__umulhisi3():
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:564
 314:	a2 9f       	mul	r26, r18
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:565
 316:	b0 01       	movw	r22, r0
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:566
 318:	b3 9f       	mul	r27, r19
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:567
 31a:	c0 01       	movw	r24, r0
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:568
 31c:	a3 9f       	mul	r26, r19
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:573
 31e:	70 0d       	add	r23, r0
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:574
 320:	81 1d       	adc	r24, r1
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:575
 322:	11 24       	eor	r1, r1
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:576
 324:	91 1d       	adc	r25, r1
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:580
 326:	b2 9f       	mul	r27, r18
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:581
 328:	70 0d       	add	r23, r0
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:582
 32a:	81 1d       	adc	r24, r1
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:583
 32c:	11 24       	eor	r1, r1
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:584
 32e:	91 1d       	adc	r25, r1
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:585
 330:	08 95       	ret

00000332 <_exit>:
exit():
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2278
 332:	f8 94       	cli

00000334 <__stop_program>:
__stop_program():
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2280
 334:	ff cf       	rjmp	.-2      	; 0x334 <__stop_program>
